@model Umbraco13.Models.FundHistoricalNavViewModel

@{
    var historicalNavsData = System.Text.Json.JsonSerializer.Serialize(Model.HistoricalNavs);
}

<div id="historical-nav-container" style="margin: 40px auto 0 auto; width: 100%; max-width: 100%;">
    <h3 style="margin-bottom: 20px;">Historical NAV Values - @Model.FundName (@Model.TickerCode)</h3>

    @if (Model.HistoricalNavs != null && Model.HistoricalNavs.Count > 0)
    {
        <!-- Download Buttons -->
        <div style="display: flex; align-items: center; margin-bottom: 15px;">
            <div style="margin-right: auto;">
                <button id="sort-toggle-btn" class="btn btn-sm btn-secondary" type="button" style="margin-right: 10px;">
                    Sort: Newest First <span id="sort-indicator">↓</span>
                </button>
            </div>
            <div>
                <a href="#" id="download-hist-pdf" class="btn btn-danger" style="text-decoration: none; margin-right: 10px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-earmark-pdf" viewBox="0 0 16 16" style="margin-right: 5px; vertical-align: text-bottom;">
                        <path d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2zM9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5v2z"/>
                    </svg>
                    Download PDF
                </a>
                <a href="#" id="download-hist-excel" class="btn btn-success" style="text-decoration: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-earmark-excel" viewBox="0 0 16 16" style="margin-right: 5px; vertical-align: text-bottom;">
                        <path d="M5.884 6.68a.5.5 0 1 0-.768.64L7.349 10l-2.233 2.68a.5.5 0 0 0 .768.64L8 10.78l2.116 2.54a.5.5 0 0 0 .768-.641L8.651 10l2.233-2.68a.5.5 0 0 0-.768-.64L8 9.22 5.884 6.68z"/>
                        <path d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2zM9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5v2z"/>
                    </svg>
                    Download Excel
                </a>
            </div>
        </div>

        <!-- SVG Composite Bar Chart -->
        <div class="card mb-4">
            <div class="card-body">
                <h5 class="card-title text-center mb-4">NAV Price vs Market Price Chart</h5>
                <div id="nav-chart-container" style="width: 100%; overflow-x: auto; position: relative;">
                    <svg id="nav-chart" width="100%" height="350" preserveAspectRatio="none" style="background-color: #f8f9fa; border-radius: 8px; min-width: 600px; display: block;">
                        <!-- Chart will be rendered here by JavaScript -->
                    </svg>
                    <div id="chart-tooltip"></div>
                </div>
                <!-- Legend -->
                <div class="text-center mt-3">
                    <span class="me-4">
                        <svg width="16" height="16" style="display: inline-block; vertical-align: middle; margin-right: 5px;">
                            <rect width="16" height="16" fill="#3b82f6" rx="2"/>
                        </svg>
                        NAV Price
                    </span>
                    <span>
                        <svg width="16" height="16" style="display: inline-block; vertical-align: middle; margin-right: 5px;">
                            <rect width="16" height="16" fill="#22c55e" rx="2"/>
                        </svg>
                        Market Price
                    </span>
                </div>
            </div>
        </div>

        <div class="table-responsive">
            <table class="table table-hover" id="historical-nav-table">
                <thead class="table-light" id="historical-nav-table-head">
                    <!-- Date columns will be populated by JavaScript -->
                </thead>
                <tbody id="historical-nav-table-body">
                    <!-- Field rows will be populated by JavaScript -->
                </tbody>
            </table>
        </div>

        <!-- Pagination Controls -->
        <div class="d-flex justify-content-between align-items-center mt-3">
            <div>
                <span id="hist-pagination-info">Showing 1-5 of @Model.TotalItems dates</span>
            </div>
            <nav aria-label="Page navigation">
                <ul class="pagination mb-0" id="hist-pagination-controls">
                    <!-- Pagination buttons will be populated by JavaScript -->
                </ul>
            </nav>
        </div>

        <!-- Page Size Selector -->
        <div class="mt-3 text-end">
            <label>Show
                <select id="hist-page-size-select" class="form-select form-select-sm d-inline-block" style="width: auto;">
                    <option value="3">3</option>
                    <option value="5" selected>5</option>
                    <option value="10">10</option>
                    <option value="20">20</option>
                </select>
                dates per page
            </label>
        </div>
    }
    else
    {
        <p class="text-muted">No historical NAV data available for this fund.</p>
    }
</div>

<style>
.pagination .page-link {
    cursor: pointer;
}

.pagination .page-item.disabled .page-link {
    cursor: not-allowed;
}

.positive-change {
    color: green;
}

.negative-change {
    color: red;
}

.sort-toggle-btn {
    margin-left: auto;
    margin-right: 20px;
}

/* Chart styles */
.chart-bar {
    transition: opacity 0.2s ease;
    cursor: pointer;
}

.chart-bar:hover {
    opacity: 0.7;
}

#chart-tooltip {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 1000;
    white-space: nowrap;
}

#chart-tooltip.show {
    opacity: 1;
}
</style>

<script>
/**
 * Generic Column-Aligned Bar Chart Generator
 * Creates SVG bar charts that align with table columns
 *
 * @@param {Object} options - Chart configuration options
 * @@param {string} options.containerId - ID of the container element
 * @@param {Array} options.data - Array of data objects (one per column)
 * @@param {Array} options.series - Array of series definitions [{key, label, color, format}]
 * @@param {number} options.labelColumnWidth - Width of the label column in pixels
 * @@param {number} options.height - Chart height in pixels
 * @@param {string} options.title - Chart title
 * @@param {Object} options.yAxis - Y axis configuration {title, labelFormatter}
 * @@param {boolean} options.showGuides - Show vertical alignment guides
 * @@param {boolean} options.showBoundaries - Show column boundary markers
 *
 * @@example
 * generateColumnBarChart({
 *     containerId: 'nav-chart',
 *     data: [{NavPrice: 50, MarketPrice: 49.5, NavDate: '2025-01-01'}, ...],
 *     series: [
 *         {key: 'NavPrice', label: 'NAV Price', color: '#3b82f6', format: 'currency'},
 *         {key: 'MarketPrice', label: 'Market Price', color: '#22c55e', format: 'currency'}
 *     ],
 *     labelColumnWidth: 150,
 *     height: 350,
 *     title: 'NAV Price vs Market Price'
 * });
 */
function generateColumnBarChart(options) {
    const {
        containerId,
        data = [],
        series = [],
        labelColumnWidth = 150,
        height = 350,
        title = '',
        yAxis = { title: 'Price', labelFormatter: (v) => '$' + v.toFixed(2) },
        showGuides = true,
        showBoundaries = true
    } = options;

    const container = document.getElementById(containerId);
    if (!container || !data.length || !series.length) {
        if (container) {
            container.innerHTML = `<svg width="100%" height="${height}" style="background-color: #f8f9fa; border-radius: 8px;">
                <text x="50%" y="50%" text-anchor="middle" fill="#6c757d">No data available</text>
            </svg>`;
        }
        return;
    }

    // Get container width for full expansion
    const containerWidth = container.clientWidth || 1200;

    // Calculate dimensions
    const totalWidth = containerWidth;
    const availableWidth = totalWidth - labelColumnWidth - 20;
    const columnWidth = availableWidth / data.length;

    // Chart padding
    const chartLeft = labelColumnWidth;
    const padding = { top: 40, right: 20, bottom: 70, left: chartLeft };
    const chartWidth = totalWidth - chartLeft - padding.right;
    const chartHeight = height - padding.top - padding.bottom;

    // Find min and max values for Y axis scale
    const allValues = [];
    data.forEach(item => {
        series.forEach(s => {
            const value = item[s.key];
            if (value !== null && value !== undefined) {
                allValues.push(value);
            }
        });
    });

    if (allValues.length === 0) {
        container.innerHTML = `<svg width="100%" height="${height}" style="background-color: #f8f9fa; border-radius: 8px;">
            <text x="50%" y="50%" text-anchor="middle" fill="#6c757d">No valid data available</text>
        </svg>`;
        return;
    }

    const minValue = Math.min(...allValues) * 0.95;
    const maxValue = Math.max(...allValues) * 1.05;
    const valueRange = maxValue - minValue;

    // Calculate bar dimensions based on column width
    const barWidth = Math.min(50, columnWidth * 0.35);
    const barGap = Math.min(12, columnWidth * 0.08);

    // Create SVG namespace
    const ns = 'http://www.w3.org/2000/svg';

    // Helper functions
    const valueToY = (value) => {
        return padding.top + chartHeight - ((value - minValue) / valueRange) * chartHeight;
    };

    const indexToColumnCenter = (index) => {
        return chartLeft + (index * columnWidth) + (columnWidth / 2);
    };

    const formatDate = (dateStr) => {
        const date = new Date(dateStr);
        return date.toLocaleDateString('en-GB');
    };

    const formatValue = (value, format) => {
        switch (format) {
            case 'currency':
                return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
            case 'percent':
                return value.toFixed(2) + '%';
            case 'number':
                return value.toFixed(2);
            default:
                return value;
        }
    };

    // Build SVG content
    let svgContent = '';

    // Y axis grid lines
    const gridLineCount = 5;
    for (let i = 0; i <= gridLineCount; i++) {
        const value = minValue + (valueRange * i / gridLineCount);
        const y = valueToY(value);
        const label = yAxis.labelFormatter(value);

        svgContent += `<line x1="${chartLeft}" y1="${y}" x2="${totalWidth - padding.right}" y2="${y}" stroke="#e0e0e0" stroke-width="1" stroke-dasharray="4,4"/>`;
        svgContent += `<text x="${chartLeft - 10}" y="${y + 4}" text-anchor="end" font-size="11" fill="#6c757d">${label}</text>`;
    }

    // Y axis line
    svgContent += `<line x1="${chartLeft}" y1="${padding.top}" x2="${chartLeft}" y2="${height - padding.bottom}" stroke="#495057" stroke-width="2"/>`;

    // Vertical divider at label column boundary
    svgContent += `<line x1="${labelColumnWidth}" y1="${padding.top - 10}" x2="${labelColumnWidth}" y2="${height - padding.bottom}" stroke="#dee2e6" stroke-width="2"/>`;

    // Column center alignment guides
    if (showGuides) {
        data.forEach((item, index) => {
            const groupCenter = indexToColumnCenter(index);
            svgContent += `<line x1="${groupCenter}" y1="${padding.top}" x2="${groupCenter}" y2="${height - padding.bottom}" stroke="#3b82f6" stroke-width="1" stroke-dasharray="3,3" opacity="0.15"/>`;
        });
    }

    // Column boundary markers
    if (showBoundaries) {
        data.forEach((item, index) => {
            const colRightEdge = chartLeft + ((index + 1) * columnWidth);
            svgContent += `<line x1="${colRightEdge}" y1="${padding.top}" x2="${colRightEdge}" y2="${height - padding.bottom}" stroke="#e9ecef" stroke-width="1" stroke-dasharray="2,2"/>`;
        });
    }

    // Draw bars for each column
    data.forEach((item, colIndex) => {
        const columnCenter = indexToColumnCenter(colIndex);
        let barOffset = 0;

        series.forEach((s, seriesIndex) => {
            const value = item[s.key];
            if (value === null || value === undefined) return;

            const barY = valueToY(value);
            const barHeight = padding.top + chartHeight - barY;
            const barX = columnCenter - (barWidth * series.length / 2) + barOffset;
            const barColor = s.color || (seriesIndex === 0 ? '#3b82f6' : '#22c55e');

            svgContent += `<rect class="chart-bar" x="${barX}" y="${barY}" width="${barWidth}" height="${barHeight}" fill="${barColor}" rx="3" data-value="${value}" data-type="${s.label}" data-series="${seriesIndex}"/>`;
            barOffset += barWidth + barGap;
        });
    });

    // X axis labels (get first date key or use index)
    const dateKey = data[0].NavDate ? 'NavDate' : (data[0].Date ? 'Date' : null);
    if (dateKey) {
        data.forEach((item, index) => {
            const columnCenter = indexToColumnCenter(index);
            const dateLabel = formatDate(item[dateKey]);
            svgContent += `<text x="${columnCenter}" y="${height - padding.bottom + 25}" text-anchor="middle" font-size="12" font-weight="500" fill="#495057">${dateLabel}</text>`;
        });
    }

    // X axis line
    svgContent += `<line x1="${chartLeft}" y1="${height - padding.bottom}" x2="${totalWidth - padding.right}" y2="${height - padding.bottom}" stroke="#495057" stroke-width="2"/>`;

    // Y axis title (rotated)
    svgContent += `<text x="${-height / 2}" y="15" transform="rotate(-90)" text-anchor="middle" font-size="12" font-weight="bold" fill="#495057">${yAxis.title}</text>`;

    // Create SVG element
    const svg = document.createElementNS(ns, 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${totalWidth} ${height}`);
    svg.setAttribute('preserveAspectRatio', 'none');
    svg.style.backgroundColor = '#f8f9fa';
    svg.style.borderRadius = '8px';
    svg.style.display = 'block';
    svg.innerHTML = svgContent;

    // Clear container and append SVG
    container.innerHTML = '';
    container.appendChild(svg);

    // Setup tooltips
    setupChartTooltips(container);

    // Return SVG element for further manipulation
    return svg;
}

/**
 * Setup tooltip functionality for chart bars
 */
function setupChartTooltips(container) {
    // Find or create tooltip element
    let tooltip = document.getElementById('chart-tooltip');
    if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'chart-tooltip';
        tooltip.style.cssText = 'position: absolute; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s ease; z-index: 1000; white-space: nowrap;';
        // Append to parent container (not the chart container) so it survives re-renders
        if (container.parentElement) {
            container.parentElement.appendChild(tooltip);
        } else {
            container.appendChild(tooltip);
        }
    }

    const bars = container.querySelectorAll('.chart-bar');
    bars.forEach(bar => {
        bar.addEventListener('mouseenter', function(e) {
            const value = this.getAttribute('data-value');
            const type = this.getAttribute('data-type');
            const color = this.getAttribute('fill');
            tooltip.innerHTML = `<strong style="color: ${color}">${type}</strong><br>${value}`;
            tooltip.classList.add('show');
            tooltip.style.opacity = '1';
        });

        bar.addEventListener('mousemove', function(e) {
            const rect = container.getBoundingClientRect();
            tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (e.clientY - rect.top - 40) + 'px';
        });

        bar.addEventListener('mouseleave', function() {
            tooltip.style.opacity = '0';
        });
    });
}

// Make functions globally accessible
window.generateColumnBarChart = generateColumnBarChart;
window.setupChartTooltips = setupChartTooltips;

(function() {
    // Data and state
    let allHistoricalNavs = @Html.Raw(historicalNavsData);
    let currentPage = 1;
    let pageSize = 5;
    let sortDirection = 'desc'; // Sort by date (newest first)

    // Define rows and their display order
    const fieldRows = [
        { key: 'NavPrice', label: 'NAV Price', format: 'currency', align: 'center' },
        { key: 'MarketPrice', label: 'Market Price', format: 'currency', align: 'center' },
        { key: 'DailyChangePercent', label: 'Daily Change %', format: 'percent', align: 'center' },
        { key: 'NetAssetValue', label: 'Net Asset Value (M)', format: 'currency', align: 'center' }
    ];

    // Sort by date
    function sortHistoricalNavs(navData, direction) {
        return navData.sort((a, b) => {
            const dateA = new Date(a.NavDate);
            const dateB = new Date(b.NavDate);
            return direction === 'asc' ? dateA - dateB : dateB - dateA;
        });
    }

    // Format date
    function formatDate(dateStr) {
        const date = new Date(dateStr);
        return date.toLocaleDateString('en-GB');
    }

    // Format currency
    function formatCurrency(value) {
        return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
    }

    // Format percentage
    function formatPercentage(value) {
        return value.toFixed(2) + '%';
    }

    // Get formatted value
    function getFormattedValue(value, format) {
        switch (format) {
            case 'currency':
                return formatCurrency(value);
            case 'percent':
                const formatted = formatPercentage(value);
                const sign = value >= 0 ? '+' : '';
                const colorClass = value >= 0 ? 'positive-change' : 'negative-change';
                return { text: sign + formatted, class: colorClass };
            default:
                return value;
        }
    }

    // Render SVG composite bar chart - uses generic chart generator
    function renderChart(paginatedNavs) {
        const svg = document.getElementById('nav-chart');
        if (!svg) return;

        if (paginatedNavs.length === 0) {
            svg.setAttribute('viewBox', '0 0 600 350');
            svg.innerHTML = '<text x="300" y="175" text-anchor="middle" fill="#6c757d">No data available</text>';
            return;
        }

        generateColumnBarChart({
            containerId: 'nav-chart',
            data: paginatedNavs,
            series: [
                { key: 'NavPrice', label: 'NAV Price', color: '#3b82f6', format: 'currency' },
                { key: 'MarketPrice', label: 'Market Price', color: '#22c55e', format: 'currency' }
            ],
            labelColumnWidth: 150,
            height: 350,
            title: 'NAV Price vs Market Price',
            yAxis: {
                title: 'Price (USD)',
                labelFormatter: (v) => '$' + v.toFixed(2)
            },
            showGuides: true,
            showBoundaries: true
        });
    }

    // Render table header (dates as columns)
    function renderTableHeader(paginatedNavs) {
        const thead = document.getElementById('historical-nav-table-head');
        thead.innerHTML = '';

        // Create header row
        const headerRow = document.createElement('tr');

        // First cell is empty (row labels column)
        const emptyTh = document.createElement('th');
        emptyTh.className = 'table-light';
        emptyTh.style.width = '150px';
        headerRow.appendChild(emptyTh);

        // Add date columns
        paginatedNavs.forEach(nav => {
            const th = document.createElement('th');
            th.className = 'table-light text-center';
            th.style.minWidth = '120px';
            th.textContent = formatDate(nav.NavDate);
            headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
    }

    // Render table body (fields as rows)
    function renderTableBody() {
        const tbody = document.getElementById('historical-nav-table-body');
        tbody.innerHTML = '';

        if (allHistoricalNavs.length === 0) {
            tbody.innerHTML = '<tr><td class="text-center text-muted" colspan="10">No data available</td></tr>';
            return;
        }

        // Sort by date
        let sortedNavs = sortHistoricalNavs([...allHistoricalNavs], sortDirection);

        // Paginate
        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const paginatedNavs = sortedNavs.slice(startIndex, endIndex);

        // Render header with dates
        renderTableHeader(paginatedNavs);

        // Render chart
        renderChart(paginatedNavs);

        // Render each field as a row
        fieldRows.forEach(field => {
            const row = document.createElement('tr');

            // First cell is the field label
            const labelCell = document.createElement('td');
            labelCell.textContent = field.label;
            labelCell.style.fontWeight = 'bold';
            labelCell.style.textAlign = 'center';
            row.appendChild(labelCell);

            // Add values for each date
            paginatedNavs.forEach(nav => {
                const cell = document.createElement('td');
                cell.className = `text-${field.align}`;

                const value = nav[field.key];
                if (field.format === 'percent') {
                    const result = getFormattedValue(value, field.format);
                    cell.innerHTML = `<span class="${result.class}">${result.text}</span>`;
                } else {
                    cell.textContent = getFormattedValue(value, field.format);
                }

                row.appendChild(cell);
            });

            tbody.appendChild(row);
        });

        // Update pagination info
        const totalItems = allHistoricalNavs.length;
        const showingStart = totalItems === 0 ? 0 : startIndex + 1;
        const showingEnd = Math.min(endIndex, totalItems);
        document.getElementById('hist-pagination-info').textContent =
            `Showing ${showingStart}-${showingEnd} of ${totalItems} dates`;

        renderPaginationControls(totalItems);
    }

    // Render pagination controls
    function renderPaginationControls(totalItems) {
        const totalPages = Math.ceil(totalItems / pageSize);
        const pagination = document.getElementById('hist-pagination-controls');

        if (!pagination) return;

        pagination.innerHTML = '';

        // Previous button
        const prevLi = document.createElement('li');
        prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
        prevLi.innerHTML = `<a class="page-link" href="#" data-page="${currentPage - 1}">Previous</a>`;
        pagination.appendChild(prevLi);

        // Page numbers
        let startPage = Math.max(1, currentPage - 2);
        let endPage = Math.min(totalPages, startPage + 4);
        startPage = Math.max(1, endPage - 4);

        for (let i = startPage; i <= endPage; i++) {
            const pageLi = document.createElement('li');
            pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
            pageLi.innerHTML = `<a class="page-link" href="#" data-page="${i}">${i}</a>`;
            pagination.appendChild(pageLi);
        }

        // Next button
        const nextLi = document.createElement('li');
        nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
        nextLi.innerHTML = `<a class="page-link" href="#" data-page="${currentPage + 1}">Next</a>`;
        pagination.appendChild(nextLi);
    }

    // Toggle sort direction
    function toggleSort() {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
        currentPage = 1;
        renderTableBody();
        updateSortButton();
    }

    // Update sort button display
    function updateSortButton() {
        const btn = document.getElementById('sort-toggle-btn');
        const indicator = document.getElementById('sort-indicator');
        if (btn && indicator) {
            if (sortDirection === 'desc') {
                btn.textContent = 'Sort: Newest First ';
                indicator.textContent = '↓';
            } else {
                btn.textContent = 'Sort: Oldest First ';
                indicator.textContent = '↑';
            }
        }
    }

    // Event listeners
    document.addEventListener('click', function(e) {
        // Handle sort toggle button
        if (e.target.closest('#sort-toggle-btn')) {
            e.preventDefault();
            toggleSort();
            return;
        }

        // Handle pagination click
        const pageLink = e.target.closest('.page-link');
        if (pageLink && pageLink.dataset.page) {
            e.preventDefault();
            const newPage = parseInt(pageLink.dataset.page);
            const totalPages = Math.ceil(allHistoricalNavs.length / pageSize);

            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                renderTableBody();
            }
        }
    });

    document.addEventListener('change', function(e) {
        if (e.target.id === 'hist-page-size-select') {
            pageSize = parseInt(e.target.value);
            currentPage = 1;
            renderTableBody();
        }
    });

    // Update download links when tokens are fetched
    function updateHistoricalDownloadLinks(tokens) {
        const fundId = @Model.FundId;
        document.getElementById('download-hist-pdf').href = `/funds/historical-nav-pdf/${fundId}?token=${tokens.pdf}`;
        document.getElementById('download-hist-excel').href = `/funds/historical-nav-excel/${fundId}?token=${tokens.excelGeneric}`;
    }

    // Listen for token updates from main page
    if (window.updateHistoricalDownloadLinks) {
        window.updateHistoricalDownloadLinks = updateHistoricalDownloadLinks;
    }

    // Initial render
    renderTableBody();
    updateSortButton();

    // Handle window resize to adjust chart width
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            renderTableBody(); // Re-render to update chart width
        }, 250);
    });
})();
</script>
